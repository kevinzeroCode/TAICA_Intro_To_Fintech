# -*- coding: utf-8 -*-
"""HW4_SAMPLE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u4Sy9u5ZHeVtMUuz0tOukA06IN1TF5T7
"""

import numpy as np
import pandas as pd
import math

def myAction01_Sample(priceMat, rate1, rate2):
    # Explanation of my approach:
      # 1. Technical indicator used: Watch next day price
      # 2. if next day price > today price + transFee ==> buy
      #       * buy the best stock
      #    if next day price < today price + transFee ==> sell
      #       * sell if you are holding stock
      # 3. You should sell before buy to get cash each day
    # default
    cash = 1000.0
    nextDay = 1
    dataLen, stockCount = priceMat.shape

    stockHolding = np.zeros((dataLen, stockCount))
    actionMat = []  # An k-by-4 action matrix which holds k transaction records.

    cooldownEndDay = 0

    for day in range(0, dataLen - nextDay):
        dayPrices = priceMat[day]  # Today price of each stock
        nextDayPrices = priceMat[day + nextDay]  # Next day price of each stock

        if day > 0:
            stockHolding[day] = stockHolding[day-1]

        if day < cooldownEndDay:
            continue

        best_action = None
        max_score = 1.0

        best_sell_idx = -1

        for i in range(stockCount):
            holding = stockHolding[day][i]
            if holding > 0:
                if nextDayPrices[i] > 0:
                    loss_avoidance_score = dayPrices[i] / nextDayPrices[i]
                else:
                    loss_avoidance_score = 0

                if loss_avoidance_score > max_score:
                    max_score = loss_avoidance_score
                    best_sell_idx = i

        best_buy_idx = -1

        if cash > 0:
            for j in range(stockCount):
                if dayPrices[j] > 0:
                    profit_ratio = (nextDayPrices[j] * (1.0 - rate2)) / (dayPrices[j] * (1.0 + rate1))
                else:
                    profit_ratio = 0

                if profit_ratio > max_score:
                    max_score = profit_ratio
                    best_buy_idx = j

        if best_sell_idx != -1 and dayPrices[best_sell_idx] / nextDayPrices[best_sell_idx] == max_score:
            sell_units = stockHolding[day][best_sell_idx]
            sell_amount = sell_units * dayPrices[best_sell_idx]
            cash += sell_units * dayPrices[best_sell_idx] * (1.0 - rate2)
            stockHolding[day][best_sell_idx] = 0.0

            best_action = [day, best_sell_idx, -1, sell_amount]

            cooldownEndDay = day + 3 # cool down

        elif best_buy_idx != -1 and max_score > 1.0:
            buy_amount = cash
            units_to_buy = buy_amount * (1.0 - rate1) / dayPrices[best_buy_idx]
            stockHolding[day][best_buy_idx] += units_to_buy
            cash = 0.0
            best_action = [day, -1, best_buy_idx, buy_amount]

            cooldownEndDay = day + 3 # cool down

        if best_action is not None:
            actionMat.append(best_action)

    return actionMat

def myAction03_Sample(priceMatHistory, priceMatFuture, position, actionHistory, rate1, rate2):
    # The logic is same as myAction01_Sample
    # Remember to return None if there's no action for that day
    # 設定極小的容忍度，用於判斷金額是否有效 (避免浮點數誤差)
    EPSILON = 1e-10

    stockCount = priceMatHistory.shape[1]
    day_p = priceMatHistory.shape[0] - 1

    todayPrices = priceMatHistory[-1]
    holdings = position[:-1]
    cash = position[-1]

    # Initialize the default action (HOLD)
    action = np.array([day_p, 0, 0, 0])

    if len(actionHistory) != 0:
      if day_p < actionHistory[-1][0] + 3:
        return None

    if priceMatFuture.size == 0:
        for i in range(stockCount):
            if holdings[i] > EPSILON:
                sell_amount = holdings[i] * todayPrices[i]
                return np.array([day_p, i, -1, sell_amount])
        return None

    nextDayPrices = priceMatFuture[0]

    max_loss_ratio = 1.0
    best_sell_stock_idx = -1
    for i in range(stockCount):
        if holdings[i] > EPSILON:
            if nextDayPrices[i] > 0:
                loss_ratio = todayPrices[i] / nextDayPrices[i]
            else:
                loss_ratio = 0

            if loss_ratio > max_loss_ratio:
                max_loss_ratio = loss_ratio
                best_sell_stock_idx = i

    if best_sell_stock_idx != -1:
        sell_amount = holdings[best_sell_stock_idx] * todayPrices[best_sell_stock_idx]
        if sell_amount > EPSILON:
            return np.array([day_p, best_sell_stock_idx, -1, sell_amount])
        else:
            best_sell_stock_idx = -1

    if cash > EPSILON:
        max_profit_ratio = 1.0
        best_buy_stock_idx = -1

        for j in range(stockCount):
            if todayPrices[j] > 0:
                profit_ratio = (nextDayPrices[j] * (1.0 - rate2)) / (todayPrices[j] * (1.0 + rate1))
            else:
                 profit_ratio = 0

            if profit_ratio > max_profit_ratio:
                max_profit_ratio = profit_ratio
                best_buy_stock_idx = j

        if best_buy_stock_idx != -1:
            buy_amount = cash
            return np.array([day_p, -1, best_buy_stock_idx, buy_amount])

    return None

def _generate_intervals_for_stock(prices, stock_idx, rate1, rate2):
    m = len(prices)
    intervals = []

    # 1. 長區間：local minima → maxima（原本你有的）
    day = 0
    while day < m - 1:
        while day < m - 1 and prices[day+1] <= prices[day]:
            day += 1
        buy = day

        while day < m - 1 and prices[day+1] >= prices[day]:
            day += 1
        sell = day

        if sell - buy >= 3 and prices[buy] > 0 and prices[sell] > 0:
            pf = (prices[sell] * (1-rate2)) / (prices[buy] * (1+rate1))
            if pf > 1.002:   # 比原本 1.0001 強一點
                intervals.append((buy, sell, stock_idx, math.log(pf)))
        day += 1

    # 2. 加短波段：往後看 3、5、10 天
    horizons = [3, 5, 10]
    for buy in range(m):
        bp = prices[buy]
        if bp <= 0:
            continue
        for h in horizons:
            sell = buy + h
            if sell < m and prices[sell] > 0 and sell - buy >= 3:
                pf = (prices[sell] * (1-rate2)) / (prices[buy] * (1+rate1))
                if pf > 1.003:  # >0.3%
                    intervals.append((buy, sell, stock_idx, math.log(pf)))

    # 3. 次級峰谷：往後每 1 天回溯一次找次級頂點
    for buy in range(m):
        for sell in range(buy+3, min(buy+15, m)):  # 只看 15 天以內，避免爆炸
            if prices[buy] > 0 and prices[sell] > 0:
                pf = (prices[sell] * (1-rate2)) / (prices[buy] * (1+rate1))
                if pf > 1.003:  # 只保留小幅上漲
                    intervals.append((buy, sell, stock_idx, math.log(pf)))

    return intervals

# --------------------------------------------------------
# 工具函式 2：給定所有候選區間，做「無交易數量限制」的加權區間排程 DP
# --------------------------------------------------------
def _weighted_interval_scheduling(intervals):
    """
    intervals: list of (buy_day, sell_day, stock_idx, log_weight)
    回傳: 被選到的區間 list (同樣的 tuple)，照 buy_day 排序
    """
    if not intervals:
        return []

    # 依照 sell_day 排序
    intervals = sorted(intervals, key=lambda x: x[1])
    m = len(intervals)

    # p[i]: 對第 i 個區間，往前找到最後一個「不衝突且滿足 cooldown」的區間 index，找不到則 -1
    p = [-1] * m
    for i in range(m):
        buy_i, sell_i, _, _ = intervals[i]
        j = i - 1
        while j >= 0:
            buy_j, sell_j, _, _ = intervals[j]
            # 需要 buy_i >= sell_j + 3 才不違反 cooldown
            if buy_i >= sell_j + 3:
                p[i] = j
                break
            j -= 1

    # 一維 DP：dp[i] = 用到第 i 個區間（含）時的最大 log-報酬
    dp = [0.0] * m
    choose = [False] * m

    for i in range(m):
        _, _, _, w_i = intervals[i]
        # 不選 i
        best_without_i = dp[i - 1] if i > 0 else 0.0
        # 選 i
        best_with_i = w_i + (dp[p[i]] if p[i] != -1 else 0.0)

        if best_with_i > best_without_i:
            dp[i] = best_with_i
            choose[i] = True
        else:
            dp[i] = best_without_i
            choose[i] = False

    # 回溯出被選到的區間
    chosen = []
    i = m - 1
    while i >= 0:
        if choose[i]:
            chosen.append(intervals[i])
            i = p[i]
        else:
            i -= 1

    chosen.sort(key=lambda x: x[0])  # 依 buy_day 排序，產生 action 時比較直覺
    return chosen

# --------------------------------------------------------
# 工具函式 3：加權區間排程 + 「最多 C 個區間」限制 (C = floor(K/2))
# --------------------------------------------------------
def _weighted_interval_scheduling_with_limit(intervals, max_intervals):
    """
    intervals: list of (buy_day, sell_day, stock_idx, log_weight)
    max_intervals: 最多可以選幾個區間 (<= floor(K/2))
    回傳: 被選到的區間 list，照 buy_day 排序
    """
    if not intervals or max_intervals <= 0:
        return []

    intervals = sorted(intervals, key=lambda x: x[1])
    m = len(intervals)
    max_intervals = min(max_intervals, m)

    # p[i] 跟前面一樣
    p = [-1] * m
    for i in range(m):
        buy_i, sell_i, _, _ = intervals[i]
        j = i - 1
        while j >= 0:
            buy_j, sell_j, _, _ = intervals[j]
            if buy_i >= sell_j + 3:
                p[i] = j
                break
            j -= 1

    # dp[i][c]：考慮到第 i 個區間（0..i），選了 c 個區間時的最大 log-報酬
    # 這裡用 (m+1) x (max_intervals+1) 的 2D 陣列，i 從 0..m，0 代表「沒有區間」
    dp = [[0.0] * (max_intervals + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        _, _, _, w_i = intervals[i - 1]
        for c in range(0, max_intervals + 1):
            # 選擇不拿第 i 個區間
            best = dp[i - 1][c]

            # 如果要拿第 i 個區間，c 至少要 >= 1
            if c > 0:
                prev_idx = p[i - 1]
                prev_row = prev_idx + 1  # 因為 dp 多了一列 0
                candidate = w_i + dp[prev_row][c - 1]
                if candidate > best:
                    best = candidate

            dp[i][c] = best

    # 從最後一列找「在 0..max_intervals 之中，哪個 c 的報酬最大」
    best_c = 0
    best_val = dp[m][0]
    for c in range(1, max_intervals + 1):
        if dp[m][c] > best_val:
            best_val = dp[m][c]
            best_c = c

    # 回溯
    chosen = []
    i = m
    c = best_c
    while i > 0 and c > 0:
        # 若 dp[i][c] 跟 dp[i-1][c] 不同，表示「有選第 i 個區間」
        if dp[i][c] > dp[i - 1][c] + 1e-12:
            interval = intervals[i - 1]
            chosen.append(interval)
            _, _, _, w_i = interval
            prev_idx = p[i - 1]
            i = prev_idx + 1
            c -= 1
        else:
            i -= 1

    chosen.sort(key=lambda x: x[0])
    return chosen

# A DP-based approach to obtain the optimal return
def myAction01(priceMat, rate1, rate2):
    dataLen, stockCount = priceMat.shape

    # 1. 產生所有候選區間
    intervals = []
    for s in range(stockCount):
        prices = priceMat[:, s]
        intervals.extend(_generate_intervals_for_stock(prices, s, rate1, rate2))

    # 2. global WIS
    chosen = _weighted_interval_scheduling(intervals)

    # 3. 轉成 actionMat
    actionMat = []
    BIG_CASH = 10**9  # 買賣都用大數字，實際會被 judge 限制成「全部資金 / 全部持股」

    for buy_day, sell_day, stock_idx, _ in chosen:
        actionMat.append([int(buy_day), -1, int(stock_idx), float(BIG_CASH)])   # buy
        actionMat.append([int(sell_day), int(stock_idx), -1, float(BIG_CASH)])  # sell

    return actionMat


# An approach that allow at most K transactions in total
def myAction02(priceMat, rate1, rate2, K):
    dataLen, stockCount = priceMat.shape

    if K <= 0 or dataLen == 0:
        return []

    max_intervals = K // 2
    if max_intervals == 0:
        return []

    # 1. 產生所有候選區間
    intervals = []
    for s in range(stockCount):
        prices = priceMat[:, s]
        intervals.extend(_generate_intervals_for_stock(prices, s, rate1, rate2))

    if not intervals:
        return []

    # 2. global WIS + 數量限制
    chosen = _weighted_interval_scheduling_with_limit(intervals, max_intervals)

    # 3. 轉成 actionMat，長度會是 2 * len(chosen) <= K
    actionMat = []
    BIG_CASH = 10**9

    for buy_day, sell_day, stock_idx, _ in chosen:
        actionMat.append([int(buy_day), -1, int(stock_idx), float(BIG_CASH)])   # buy
        actionMat.append([int(sell_day), int(stock_idx), -1, float(BIG_CASH)])  # sell

    return actionMat

# An approach for online-mode prices
def myAction03(priceMatHistory, priceMatFuture, position, actionHistory, rate1, rate2):
    EPS = 1e-12

    stockCount = priceMatHistory.shape[1]
    day_p = priceMatHistory.shape[0] - 1

    today = priceMatHistory[-1]
    holdings = position[:-1]
    cash = position[-1]

    # ===== Cooldown check =====
    if len(actionHistory) > 0:
        last_day = actionHistory[-1][0]
        # cooldown: must wait >= 3 days
        if day_p < last_day + 3:
            return None

    # ===== If tomorrow is unknown, must liquidate on the last day =====
    if priceMatFuture.size == 0:
        for i in range(stockCount):
            if holdings[i] > EPS:
                # sell entire holding
                z = holdings[i] * today[i]
                return np.array([day_p, i, -1, z], dtype=float)
        return None

    tomorrow = priceMatFuture[0]

    # ========================
    #   DP: Evaluate 3 types of actions
    # ========================

    best_gain = 0.0
    best_action = None  # format: [day, a, b, z]

    # -------------------------------------------------------
    # Action type 1: SELL a stock i (one-step DP)
    # Gain = (tomorrow_cash_after_sell - today_hold_value)
    # 但真正要 maximize 的是「明天後的價值 vs 今天價值」
    # 但最後一天我們也會賣掉，所以對 online DP：
    # SELL if tomorrow 比今天更差（扣手續費）
    # -------------------------------------------------------
    for i in range(stockCount):
        if holdings[i] > EPS and today[i] > 0 and tomorrow[i] > 0:
            # today value (before fees)
            v_today = holdings[i] * today[i]
            # tomorrow value (after selling)
            v_tomorrow = holdings[i] * tomorrow[i] * (1 - rate2)

            gain = v_tomorrow - v_today  # one-step reward

            if gain < 0:  # DP: 若明天更差 → 優先賣
                if -gain > best_gain:
                    best_gain = -gain
                    best_action = [day_p, i, -1, v_today]

    # -------------------------------------------------------
    # Action type 2: BUY a stock j
    # Gain = tomorrow_value_after_fee - today_buy_cost
    # -------------------------------------------------------
    if cash > EPS:
        for j in range(stockCount):
            if today[j] > 0 and tomorrow[j] > 0:
                # Buy amount = cash
                units = (cash * (1 - rate1)) / today[j]
                if units <= 0:
                    continue

                today_cost = cash  # spent cash
                tomorrow_value = units * tomorrow[j] * (1 - rate2)

                gain = tomorrow_value - today_cost

                if gain > best_gain:
                    best_gain = gain
                    best_action = [day_p, -1, j, cash]

    # -------------------------------------------------------
    # Action type 3: Hold (no action)
    # DP: If no action yields positive difference → hold
    # -------------------------------------------------------
    if best_action is None:
        return None

    return np.array(best_action, dtype=float)